// Generated by dust (version 0.11.18) - do not edit
#include <cpp11.hpp>

[[cpp11::register]]
cpp11::sexp dust_model_capabilities();

[[cpp11::register]]
cpp11::sexp dust_model_gpu_info();
[[cpp11::register]]
SEXP dust_cpu_model_alloc(cpp11::list r_pars, bool pars_multi, size_t step,
                         cpp11::sexp r_n_particles, size_t n_threads,
                         cpp11::sexp r_seed, bool deterministic,
                         cpp11::sexp gpu_config);

[[cpp11::register]]
SEXP dust_cpu_model_run(SEXP ptr, size_t step_end);

[[cpp11::register]]
SEXP dust_cpu_model_simulate(SEXP ptr, cpp11::sexp step_end);

[[cpp11::register]]
SEXP dust_cpu_model_set_index(SEXP ptr, cpp11::sexp r_index);

[[cpp11::register]]
SEXP dust_cpu_model_update_state(SEXP ptr, SEXP r_pars, SEXP r_state,
                                SEXP r_step, SEXP r_set_initial_state);

[[cpp11::register]]
SEXP dust_cpu_model_state(SEXP ptr, SEXP r_index);

[[cpp11::register]]
size_t dust_cpu_model_step(SEXP ptr);

[[cpp11::register]]
void dust_cpu_model_reorder(SEXP ptr, cpp11::sexp r_index);

[[cpp11::register]]
SEXP dust_cpu_model_resample(SEXP ptr, cpp11::doubles r_weights);

[[cpp11::register]]
SEXP dust_cpu_model_rng_state(SEXP ptr, bool first_only, bool last_only);

[[cpp11::register]]
SEXP dust_cpu_model_set_rng_state(SEXP ptr, cpp11::raws rng_state);

[[cpp11::register]]
SEXP dust_cpu_model_set_data(SEXP ptr, cpp11::list data);

[[cpp11::register]]
SEXP dust_cpu_model_compare_data(SEXP ptr);

[[cpp11::register]]
SEXP dust_cpu_model_filter(SEXP ptr, bool save_trajectories,
                          cpp11::sexp step_snapshot);

[[cpp11::register]]
void dust_cpu_model_set_n_threads(SEXP ptr, int n_threads);

[[cpp11::register]]
int dust_cpu_model_n_state(SEXP ptr);
#include <dust/r/dust.hpp>

// Generated by odin.dust (version 0.2.15) - do not edit
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum1(const container x, size_t from, size_t to);
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1);
template <typename real_type, typename T, typename U>
__host__ __device__ real_type fmodr(T x, U y) {
  real_type tmp = std::fmod(static_cast<real_type>(x),
                            static_cast<real_type>(y));
  if (tmp * y < 0) {
    tmp += y;
  }
  return tmp;
}

// These exist to support the model on the gpu, as in C++14 std::min
// and std::max are constexpr and error without --expt-relaxed-constexpr
template <typename T>
__host__ __device__ T odin_min(T x, T y) {
  return x < y ? x : y;
}

template <typename T>
__host__ __device__ T odin_max(T x, T y) {
  return x > y ? x : y;
}
// [[dust::class(model)]]
// [[dust::param(A0, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(E0, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(F0, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(I0, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(R0, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(S10, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(S20, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(U0, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(alpha, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_A, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_E, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_F, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_I, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_R, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(delta_S, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(m, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(omega, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(p_F, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(p_I, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(p_R, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(p_S, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(sigma, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(t_s, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(n_group, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(t0, has_default = TRUE, default_value = 0L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
class model {
public:
  using real_type = double;
  using rng_state_type = dust::random::generator<real_type>;
  using data_type = dust::no_data;
  struct shared_type {
    std::vector<real_type> A0;
    std::vector<real_type> E0;
    std::vector<real_type> F0;
    std::vector<real_type> I0;
    std::vector<real_type> R0;
    std::vector<real_type> S10;
    std::vector<real_type> S20;
    std::vector<real_type> U0;
    std::vector<real_type> alpha;
    real_type beta;
    real_type delta_A;
    real_type delta_E;
    real_type delta_F;
    real_type delta_I;
    real_type delta_R;
    real_type delta_S;
    int dim_A;
    int dim_A0;
    int dim_E;
    int dim_E0;
    int dim_F;
    int dim_F0;
    int dim_I;
    int dim_I0;
    int dim_N;
    int dim_R;
    int dim_R0;
    int dim_S1;
    int dim_S10;
    int dim_S2;
    int dim_S20;
    int dim_U;
    int dim_U0;
    int dim_alpha;
    int dim_foi;
    int dim_lambda;
    int dim_lambda_1;
    int dim_lambda_2;
    int dim_m;
    int dim_m_1;
    int dim_m_2;
    int dim_n_A;
    int dim_n_AR;
    int dim_n_AU;
    int dim_n_Ax;
    int dim_n_E;
    int dim_n_EI;
    int dim_n_ES;
    int dim_n_Ex;
    int dim_n_F;
    int dim_n_FR;
    int dim_n_Fx;
    int dim_n_I;
    int dim_n_IR;
    int dim_n_Ix;
    int dim_n_Nx;
    int dim_n_R;
    int dim_n_RU;
    int dim_n_Rx;
    int dim_n_S1;
    int dim_n_S1x;
    int dim_n_S2;
    int dim_n_S2x;
    int dim_n_SF;
    int dim_n_SR;
    int dim_n_SS;
    int dim_n_U;
    int dim_n_UA;
    int dim_n_UE;
    int dim_n_Ux;
    int dim_n_xU;
    int dim_omega;
    int dim_r_A;
    int dim_r_AR;
    int dim_r_AU;
    int dim_r_E;
    int dim_r_EI;
    int dim_r_ES;
    int dim_r_F;
    int dim_r_FR;
    int dim_r_I;
    int dim_r_IR;
    int dim_r_R;
    int dim_r_RU;
    int dim_r_S1;
    int dim_r_S2;
    int dim_r_SF;
    int dim_r_SR;
    int dim_r_SS;
    int dim_r_U;
    int dim_r_UA;
    int dim_r_UE;
    real_type dt;
    std::vector<real_type> initial_A;
    std::vector<real_type> initial_E;
    std::vector<real_type> initial_F;
    std::vector<real_type> initial_I;
    std::vector<real_type> initial_N;
    std::vector<real_type> initial_R;
    std::vector<real_type> initial_S1;
    std::vector<real_type> initial_S2;
    std::vector<real_type> initial_U;
    real_type initial_beta_t;
    real_type initial_entrants_inc;
    real_type initial_igas_inc;
    real_type initial_infections_inc;
    real_type initial_leavers_inc;
    real_type initial_pharyngitis_inc;
    real_type initial_scarlet_fever_inc;
    real_type initial_time;
    std::vector<real_type> m;
    int n_group;
    int offset_variable_A;
    int offset_variable_E;
    int offset_variable_F;
    int offset_variable_I;
    int offset_variable_N;
    int offset_variable_R;
    int offset_variable_S1;
    int offset_variable_S2;
    std::vector<real_type> omega;
    real_type p_F;
    real_type p_I;
    real_type p_R;
    real_type p_S;
    real_type pi;
    std::vector<real_type> r_A;
    std::vector<real_type> r_AR;
    std::vector<real_type> r_AU;
    std::vector<real_type> r_E;
    std::vector<real_type> r_EI;
    std::vector<real_type> r_ES;
    std::vector<real_type> r_F;
    std::vector<real_type> r_FR;
    std::vector<real_type> r_I;
    std::vector<real_type> r_IR;
    std::vector<real_type> r_R;
    std::vector<real_type> r_RU;
    std::vector<real_type> r_S1;
    std::vector<real_type> r_S2;
    std::vector<real_type> r_SF;
    std::vector<real_type> r_SR;
    std::vector<real_type> r_SS;
    real_type sigma;
    real_type steps_per_week;
    real_type t0;
    real_type t_s;
  };
  struct internal_type {
    std::vector<real_type> foi;
    std::vector<real_type> lambda;
    std::vector<real_type> n_A;
    std::vector<real_type> n_AR;
    std::vector<real_type> n_AU;
    std::vector<real_type> n_Ax;
    std::vector<real_type> n_E;
    std::vector<real_type> n_EI;
    std::vector<real_type> n_ES;
    std::vector<real_type> n_Ex;
    std::vector<real_type> n_F;
    std::vector<real_type> n_FR;
    std::vector<real_type> n_Fx;
    std::vector<real_type> n_I;
    std::vector<real_type> n_IR;
    std::vector<real_type> n_Ix;
    std::vector<real_type> n_Nx;
    std::vector<real_type> n_R;
    std::vector<real_type> n_RU;
    std::vector<real_type> n_Rx;
    std::vector<real_type> n_S1;
    std::vector<real_type> n_S1x;
    std::vector<real_type> n_S2;
    std::vector<real_type> n_S2x;
    std::vector<real_type> n_SF;
    std::vector<real_type> n_SR;
    std::vector<real_type> n_SS;
    std::vector<real_type> n_U;
    std::vector<real_type> n_UA;
    std::vector<real_type> n_UE;
    std::vector<real_type> n_Ux;
    std::vector<real_type> n_xU;
    std::vector<real_type> r_U;
    std::vector<real_type> r_UA;
    std::vector<real_type> r_UE;
  };
  model(const dust::pars_type<model>& pars) :
    shared(pars.shared), internal(pars.internal) {
  }
  size_t size() {
    return shared->dim_A + shared->dim_E + shared->dim_F + shared->dim_I + shared->dim_N + shared->dim_R + shared->dim_S1 + shared->dim_S2 + shared->dim_U + 8;
  }
  std::vector<real_type> initial(size_t step) {
    std::vector<real_type> state(shared->dim_A + shared->dim_E + shared->dim_F + shared->dim_I + shared->dim_N + shared->dim_R + shared->dim_S1 + shared->dim_S2 + shared->dim_U + 8);
    state[0] = shared->initial_time;
    state[1] = shared->initial_infections_inc;
    state[2] = shared->initial_pharyngitis_inc;
    state[3] = shared->initial_scarlet_fever_inc;
    state[4] = shared->initial_igas_inc;
    state[5] = shared->initial_entrants_inc;
    state[6] = shared->initial_leavers_inc;
    state[7] = shared->initial_beta_t;
    std::copy(shared->initial_U.begin(), shared->initial_U.end(), state.begin() + 8);
    std::copy(shared->initial_A.begin(), shared->initial_A.end(), state.begin() + shared->offset_variable_A);
    std::copy(shared->initial_E.begin(), shared->initial_E.end(), state.begin() + shared->offset_variable_E);
    std::copy(shared->initial_I.begin(), shared->initial_I.end(), state.begin() + shared->offset_variable_I);
    std::copy(shared->initial_S1.begin(), shared->initial_S1.end(), state.begin() + shared->offset_variable_S1);
    std::copy(shared->initial_S2.begin(), shared->initial_S2.end(), state.begin() + shared->offset_variable_S2);
    std::copy(shared->initial_F.begin(), shared->initial_F.end(), state.begin() + shared->offset_variable_F);
    std::copy(shared->initial_R.begin(), shared->initial_R.end(), state.begin() + shared->offset_variable_R);
    std::copy(shared->initial_N.begin(), shared->initial_N.end(), state.begin() + shared->offset_variable_N);
    return state;
  }
  void update(size_t step, const real_type * state, rng_state_type& rng_state, real_type * state_next) {
    const real_type * U = state + 8;
    const real_type * E = state + shared->offset_variable_E;
    const real_type * A = state + shared->offset_variable_A;
    const real_type * S1 = state + shared->offset_variable_S1;
    const real_type * S2 = state + shared->offset_variable_S2;
    const real_type * F = state + shared->offset_variable_F;
    const real_type * I = state + shared->offset_variable_I;
    const real_type * R = state + shared->offset_variable_R;
    const real_type * N = state + shared->offset_variable_N;
    const real_type infections_inc = state[1];
    const real_type pharyngitis_inc = state[2];
    const real_type scarlet_fever_inc = state[3];
    const real_type igas_inc = state[4];
    const real_type entrants_inc = state[5];
    const real_type leavers_inc = state[6];
    const real_type beta_t = state[7];
    state_next[7] = shared->beta * (1 + shared->sigma * std::cos(2 * shared->pi * (shared->t0 + step - shared->t_s) / (real_type) 365.25));
    state_next[0] = (step + 1) * shared->dt;
    for (int i = 1; i <= shared->dim_n_xU; ++i) {
      internal.n_xU[i - 1] = dust::random::poisson<real_type>(rng_state, shared->alpha[i - 1] * shared->dt);
    }
    for (int i = 1; i <= shared->dim_lambda_1; ++i) {
      for (int j = 1; j <= shared->dim_lambda_2; ++j) {
        internal.lambda[i - 1 + shared->dim_lambda_1 * (j - 1)] = beta_t * shared->m[shared->dim_m_1 * (j - 1) + i - 1] * (A[j - 1] + S1[j - 1] + S2[j - 1]) / (real_type) N[j - 1];
      }
    }
    state_next[5] = ((fmodr<real_type>(step, shared->steps_per_week) == 0 ? odin_sum1<real_type>(internal.n_xU.data(), 0, shared->dim_n_xU) : entrants_inc + odin_sum1<real_type>(internal.n_xU.data(), 0, shared->dim_n_xU)));
    for (int i = 1; i <= shared->dim_foi; ++i) {
      internal.foi[i - 1] = odin_sum2<real_type>(internal.lambda.data(), i - 1, i, 0, shared->dim_lambda_2, shared->dim_lambda_1);
    }
    for (int i = 1; i <= shared->dim_n_A; ++i) {
      internal.n_A[i - 1] = dust::random::binomial<real_type>(rng_state, A[i - 1], 1 - std::exp(- shared->r_A[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_E; ++i) {
      internal.n_E[i - 1] = dust::random::binomial<real_type>(rng_state, E[i - 1], 1 - std::exp(- shared->r_E[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_F; ++i) {
      internal.n_F[i - 1] = dust::random::binomial<real_type>(rng_state, F[i - 1], 1 - std::exp(- shared->r_F[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_I; ++i) {
      internal.n_I[i - 1] = dust::random::binomial<real_type>(rng_state, I[i - 1], 1 - std::exp(- shared->r_I[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_R; ++i) {
      internal.n_R[i - 1] = dust::random::binomial<real_type>(rng_state, R[i - 1], 1 - std::exp(- shared->r_R[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_S1; ++i) {
      internal.n_S1[i - 1] = dust::random::binomial<real_type>(rng_state, S1[i - 1], 1 - std::exp(- shared->r_S1[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_S2; ++i) {
      internal.n_S2[i - 1] = dust::random::binomial<real_type>(rng_state, S2[i - 1], 1 - std::exp(- shared->r_S2[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_n_Ax; ++i) {
      internal.n_Ax[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_A[i - 1], shared->omega[i - 1] / (real_type) shared->r_A[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_Ex; ++i) {
      internal.n_Ex[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_E[i - 1], shared->omega[i - 1] / (real_type) shared->r_E[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_Fx; ++i) {
      internal.n_Fx[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_F[i - 1], shared->omega[i - 1] / (real_type) shared->r_F[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_Ix; ++i) {
      internal.n_Ix[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_I[i - 1], shared->omega[i - 1] / (real_type) shared->r_I[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_Rx; ++i) {
      internal.n_Rx[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_R[i - 1], shared->omega[i - 1] / (real_type) shared->r_R[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_S1x; ++i) {
      internal.n_S1x[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_S1[i - 1], shared->omega[i - 1] / (real_type) shared->r_S1[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_S2x; ++i) {
      internal.n_S2x[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_S2[i - 1], shared->omega[i - 1] / (real_type) shared->r_S2[i - 1]);
    }
    for (int i = 1; i <= shared->dim_r_UA; ++i) {
      internal.r_UA[i - 1] = (1 - shared->p_S) * internal.foi[i - 1];
    }
    for (int i = 1; i <= shared->dim_r_UE; ++i) {
      internal.r_UE[i - 1] = shared->p_S * internal.foi[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_AR; ++i) {
      internal.n_AR[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_A[i - 1] - internal.n_Ax[i - 1], shared->p_R);
    }
    for (int i = 1; i <= shared->dim_n_EI; ++i) {
      internal.n_EI[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_E[i - 1] - internal.n_Ex[i - 1], shared->p_I);
    }
    for (int i = 1; i <= shared->dim_n_FR; ++i) {
      internal.n_FR[i - 1] = internal.n_F[i - 1] - internal.n_Fx[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_IR; ++i) {
      internal.n_IR[i - 1] = internal.n_I[i - 1] - internal.n_Ix[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_RU; ++i) {
      internal.n_RU[i - 1] = internal.n_R[i - 1] - internal.n_Rx[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_SF; ++i) {
      internal.n_SF[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_S1[i - 1] - internal.n_S1x[i - 1], shared->p_F);
    }
    for (int i = 1; i <= shared->dim_n_SR; ++i) {
      internal.n_SR[i - 1] = internal.n_S2[i - 1] - internal.n_S2x[i - 1];
    }
    for (int i = 1; i <= shared->dim_r_U; ++i) {
      internal.r_U[i - 1] = internal.r_UE[i - 1] + internal.r_UA[i - 1] + shared->omega[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_AU; ++i) {
      internal.n_AU[i - 1] = internal.n_A[i - 1] - internal.n_Ax[i - 1] - internal.n_AR[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_ES; ++i) {
      internal.n_ES[i - 1] = internal.n_E[i - 1] - internal.n_Ex[i - 1] - internal.n_EI[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_SS; ++i) {
      internal.n_SS[i - 1] = internal.n_S1[i - 1] - internal.n_S1x[i - 1] - internal.n_SF[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_U; ++i) {
      internal.n_U[i - 1] = dust::random::binomial<real_type>(rng_state, U[i - 1], 1 - std::exp(- internal.r_U[i - 1] * shared->dt));
    }
    for (int i = 1; i <= shared->dim_F; ++i) {
      state_next[shared->offset_variable_F + i - 1] = F[i - 1] + internal.n_SF[i - 1] - internal.n_FR[i - 1] - internal.n_Fx[i - 1];
    }
    for (int i = 1; i <= shared->dim_I; ++i) {
      state_next[shared->offset_variable_I + i - 1] = I[i - 1] + internal.n_EI[i - 1] - internal.n_IR[i - 1] - internal.n_Ix[i - 1];
    }
    for (int i = 1; i <= shared->dim_R; ++i) {
      state_next[shared->offset_variable_R + i - 1] = R[i - 1] + internal.n_AR[i - 1] + internal.n_SR[i - 1] + internal.n_FR[i - 1] + internal.n_IR[i - 1] - internal.n_RU[i - 1] - internal.n_Rx[i - 1];
    }
    state_next[4] = ((fmodr<real_type>(step, shared->steps_per_week) == 0 ? odin_sum1<real_type>(internal.n_EI.data(), 0, shared->dim_n_EI) : igas_inc + odin_sum1<real_type>(internal.n_EI.data(), 0, shared->dim_n_EI)));
    state_next[3] = ((fmodr<real_type>(step, shared->steps_per_week) == 0 ? odin_sum1<real_type>(internal.n_SF.data(), 0, shared->dim_n_SF) : scarlet_fever_inc + odin_sum1<real_type>(internal.n_SF.data(), 0, shared->dim_n_SF)));
    for (int i = 1; i <= shared->dim_n_Ux; ++i) {
      internal.n_Ux[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_U[i - 1], shared->omega[i - 1] / (real_type) internal.r_U[i - 1]);
    }
    for (int i = 1; i <= shared->dim_S1; ++i) {
      state_next[shared->offset_variable_S1 + i - 1] = S1[i - 1] + internal.n_ES[i - 1] - internal.n_SF[i - 1] - internal.n_SS[i - 1] - internal.n_S1x[i - 1];
    }
    for (int i = 1; i <= shared->dim_S2; ++i) {
      state_next[shared->offset_variable_S2 + i - 1] = S2[i - 1] + internal.n_SS[i - 1] - internal.n_SR[i - 1] - internal.n_S2x[i - 1];
    }
    state_next[2] = ((fmodr<real_type>(step, shared->steps_per_week) == 0 ? odin_sum1<real_type>(internal.n_SS.data(), 0, shared->dim_n_SS) + odin_sum1<real_type>(internal.n_SF.data(), 0, shared->dim_n_SF) : pharyngitis_inc + odin_sum1<real_type>(internal.n_SS.data(), 0, shared->dim_n_SS) + odin_sum1<real_type>(internal.n_SF.data(), 0, shared->dim_n_SF)));
    for (int i = 1; i <= shared->dim_n_Nx; ++i) {
      internal.n_Nx[i - 1] = internal.n_Ux[i - 1] + internal.n_Ex[i - 1] + internal.n_Ax[i - 1] + internal.n_S1x[i - 1] + internal.n_S2x[i - 1] + internal.n_Fx[i - 1] + internal.n_Ix[i - 1] + internal.n_Rx[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_UE; ++i) {
      internal.n_UE[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_U[i - 1] - internal.n_Ux[i - 1], shared->p_S);
    }
    for (int i = 1; i <= shared->dim_n_UA; ++i) {
      internal.n_UA[i - 1] = internal.n_U[i - 1] - internal.n_Ux[i - 1] - internal.n_UE[i - 1];
    }
    for (int i = 1; i <= shared->dim_E; ++i) {
      state_next[shared->offset_variable_E + i - 1] = E[i - 1] + internal.n_UE[i - 1] - internal.n_ES[i - 1] - internal.n_EI[i - 1] - internal.n_Ex[i - 1];
    }
    for (int i = 1; i <= shared->dim_N; ++i) {
      state_next[shared->offset_variable_N + i - 1] = N[i - 1] + internal.n_xU[i - 1] - internal.n_Nx[i - 1];
    }
    state_next[6] = ((fmodr<real_type>(step, shared->steps_per_week) == 0 ? odin_sum1<real_type>(internal.n_Nx.data(), 0, shared->dim_n_Nx) : leavers_inc + odin_sum1<real_type>(internal.n_Nx.data(), 0, shared->dim_n_Nx)));
    for (int i = 1; i <= shared->dim_A; ++i) {
      state_next[shared->offset_variable_A + i - 1] = A[i - 1] + internal.n_UA[i - 1] - internal.n_AU[i - 1] - internal.n_AR[i - 1] - internal.n_Ax[i - 1];
    }
    for (int i = 1; i <= shared->dim_U; ++i) {
      state_next[8 + i - 1] = U[i - 1] + internal.n_xU[i - 1] - internal.n_UE[i - 1] - internal.n_UA[i - 1] + internal.n_AU[i - 1] + internal.n_RU[i - 1] - internal.n_Ux[i - 1];
    }
    state_next[1] = ((fmodr<real_type>(step, shared->steps_per_week) == 0 ? odin_sum1<real_type>(internal.n_UE.data(), 0, shared->dim_n_UE) + odin_sum1<real_type>(internal.n_UA.data(), 0, shared->dim_n_UA) : infections_inc + odin_sum1<real_type>(internal.n_UE.data(), 0, shared->dim_n_UE) + odin_sum1<real_type>(internal.n_UA.data(), 0, shared->dim_n_UA)));
  }
private:
  std::shared_ptr<const shared_type> shared;
  internal_type internal;
};
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1) {
  real_type tot = 0.0;
  for (int j = from_j; j < to_j; ++j) {
    int jj = j * dim_x_1;
    for (int i = from_i; i < to_i; ++i) {
      tot += x[i + jj];
    }
  }
  return tot;
}
#include <array>
#include <cpp11/R.hpp>
#include <cpp11/sexp.hpp>
#include <cpp11/doubles.hpp>
#include <cpp11/integers.hpp>
#include <cpp11/list.hpp>
#include <cpp11/strings.hpp>
#include <memory>
#include <vector>

template <typename T>
inline bool is_na(T x);

template <>
inline bool is_na(int x) {
  return x == NA_INTEGER;
}

template <>
inline bool is_na(double x) {
  return ISNA(x);
}

inline size_t object_length(cpp11::sexp x) {
  return ::Rf_xlength(x);
}

template <typename T>
void user_check_value(T value, const char *name, T min, T max) {
  if (is_na(value)) {
    cpp11::stop("'%s' must not be NA", name);
  }
  if (!is_na(min) && value < min) {
    cpp11::stop("Expected '%s' to be at least %g", name, (double) min);
  }
  if (!is_na(max) && value > max) {
    cpp11::stop("Expected '%s' to be at most %g", name, (double) max);
  }
}

template <typename T>
void user_check_array_value(const std::vector<T>& value, const char *name,
                            T min, T max) {
  for (auto& x : value) {
    user_check_value(x, name, min, max);
  }
}

inline size_t user_get_array_rank(cpp11::sexp x) {
  if (!::Rf_isArray(x)) {
    return 1;
  } else {
    cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
    return dim.size();
  }
}

template <size_t N>
void user_check_array_rank(cpp11::sexp x, const char *name) {
  size_t rank = user_get_array_rank(x);
  if (rank != N) {
    if (N == 1) {
      cpp11::stop("Expected a vector for '%s'", name);
    } else if (N == 2) {
      cpp11::stop("Expected a matrix for '%s'", name);
    } else {
      cpp11::stop("Expected an array of rank %d for '%s'", N, name);
    }
  }
}

template <size_t N>
void user_check_array_dim(cpp11::sexp x, const char *name,
                          const std::array<int, N>& dim_expected) {
  cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  for (size_t i = 0; i < N; ++i) {
    if (dim[(int)i] != dim_expected[i]) {
      Rf_error("Incorrect size of dimension %d of '%s' (expected %d)",
               i + 1, name, dim_expected[i]);
    }
  }
}

template <>
inline void user_check_array_dim<1>(cpp11::sexp x, const char *name,
                                    const std::array<int, 1>& dim_expected) {
  if ((int)object_length(x) != dim_expected[0]) {
    cpp11::stop("Expected length %d value for '%s'", dim_expected[0], name);
  }
}

template <size_t N>
void user_set_array_dim(cpp11::sexp x, const char *name,
                        std::array<int, N>& dim) {
  cpp11::integers dim_given = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  std::copy(dim_given.begin(), dim_given.end(), dim.begin());
}

template <>
inline void user_set_array_dim<1>(cpp11::sexp x, const char *name,
                                  std::array<int, 1>& dim) {
  dim[0] = object_length(x);
}

template <typename T>
T user_get_scalar(cpp11::list user, const char *name,
                  const T previous, T min, T max) {
  T ret = previous;
  cpp11::sexp x = user[name];
  if (x != R_NilValue) {
    if (object_length(x) != 1) {
      cpp11::stop("Expected a scalar numeric for '%s'", name);
    }
    // TODO: when we're getting out an integer this is a bit too relaxed
    if (TYPEOF(x) == REALSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else if (TYPEOF(x) == INTSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else {
      cpp11::stop("Expected a numeric value for %s", name);
    }
  }

  if (is_na(ret)) {
    cpp11::stop("Expected a value for '%s'", name);
  }
  user_check_value<T>(ret, name, min, max);
  return ret;
}

template <>
inline float user_get_scalar<float>(cpp11::list user, const char *name,
                                    const float previous, float min, float max) {
  double value = user_get_scalar<double>(user, name, previous, min, max);
  return static_cast<float>(value);
}

template <typename T>
std::vector<T> user_get_array_value(cpp11::sexp x, const char * name,
                                    T min, T max) {
  std::vector<T> ret = cpp11::as_cpp<std::vector<T>>(x);
  user_check_array_value<T>(ret, name, min, max);
  return ret;
}

template <typename T, size_t N>
std::vector<T> user_get_array_fixed(cpp11::list user, const char *name,
                                    const std::vector<T> previous,
                                    const std::array<int, N>& dim,
                                    T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_check_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <typename T, size_t N>
std::vector<T> user_get_array_variable(cpp11::list user, const char *name,
                                       std::vector<T> previous,
                                       std::array<int, N>& dim,
                                       T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_set_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <>
inline std::vector<float> user_get_array_value(cpp11::sexp x, const char * name,
                                               float min, float max) {
  // NOTE: possible under/overflow here for min/max because we've
  // downcast this.
  std::vector<double> value = user_get_array_value<double>(x, name, min, max);
  std::vector<float> ret(value.size());
  std::copy(value.begin(), value.end(), ret.begin());
  return ret;
}

// This is sum with inclusive "from", exclusive "to", following the
// same function in odin
template <typename real_type, typename container>
__host__ __device__
real_type odin_sum1(const container x, size_t from, size_t to) {
  real_type tot = 0.0;
  for (size_t i = from; i < to; ++i) {
    tot += x[i];
  }
  return tot;
}

inline cpp11::writable::integers integer_sequence(size_t from, size_t len) {
  cpp11::writable::integers ret(len);
  int* data = INTEGER(ret);
  for (size_t i = 0, j = from; i < len; ++i, ++j) {
    data[i] = j;
  }
  return ret;
}
namespace dust {
template<>
dust::pars_type<model> dust_pars<model>(cpp11::list user) {
  using real_type = typename model::real_type;
  auto shared = std::make_shared<model::shared_type>();
  model::internal_type internal;
  shared->initial_beta_t = 0;
  shared->initial_entrants_inc = 0;
  shared->initial_igas_inc = 0;
  shared->initial_infections_inc = 0;
  shared->initial_leavers_inc = 0;
  shared->initial_pharyngitis_inc = 0;
  shared->initial_scarlet_fever_inc = 0;
  shared->initial_time = 0;
  shared->pi = 3.14159265358979;
  shared->steps_per_week = 7;
  shared->dt = 1 / (real_type) shared->steps_per_week;
  shared->beta = NA_REAL;
  shared->delta_A = NA_REAL;
  shared->delta_E = NA_REAL;
  shared->delta_F = NA_REAL;
  shared->delta_I = NA_REAL;
  shared->delta_R = NA_REAL;
  shared->delta_S = NA_REAL;
  shared->p_F = NA_REAL;
  shared->p_I = NA_REAL;
  shared->p_R = NA_REAL;
  shared->p_S = NA_REAL;
  shared->sigma = NA_REAL;
  shared->t_s = NA_REAL;
  shared->n_group = 1;
  shared->t0 = 0;
  shared->beta = user_get_scalar<real_type>(user, "beta", shared->beta, NA_REAL, NA_REAL);
  shared->delta_A = user_get_scalar<real_type>(user, "delta_A", shared->delta_A, NA_REAL, NA_REAL);
  shared->delta_E = user_get_scalar<real_type>(user, "delta_E", shared->delta_E, NA_REAL, NA_REAL);
  shared->delta_F = user_get_scalar<real_type>(user, "delta_F", shared->delta_F, NA_REAL, NA_REAL);
  shared->delta_I = user_get_scalar<real_type>(user, "delta_I", shared->delta_I, NA_REAL, NA_REAL);
  shared->delta_R = user_get_scalar<real_type>(user, "delta_R", shared->delta_R, NA_REAL, NA_REAL);
  shared->delta_S = user_get_scalar<real_type>(user, "delta_S", shared->delta_S, NA_REAL, NA_REAL);
  shared->n_group = user_get_scalar<int>(user, "n_group", shared->n_group, NA_REAL, NA_REAL);
  shared->p_F = user_get_scalar<real_type>(user, "p_F", shared->p_F, NA_REAL, NA_REAL);
  shared->p_I = user_get_scalar<real_type>(user, "p_I", shared->p_I, NA_REAL, NA_REAL);
  shared->p_R = user_get_scalar<real_type>(user, "p_R", shared->p_R, NA_REAL, NA_REAL);
  shared->p_S = user_get_scalar<real_type>(user, "p_S", shared->p_S, NA_REAL, NA_REAL);
  shared->sigma = user_get_scalar<real_type>(user, "sigma", shared->sigma, NA_REAL, NA_REAL);
  shared->t0 = user_get_scalar<real_type>(user, "t0", shared->t0, NA_REAL, NA_REAL);
  shared->t_s = user_get_scalar<real_type>(user, "t_s", shared->t_s, NA_REAL, NA_REAL);
  shared->dim_A = shared->n_group;
  shared->dim_A0 = shared->n_group;
  shared->dim_E = shared->n_group;
  shared->dim_E0 = shared->n_group;
  shared->dim_F = shared->n_group;
  shared->dim_F0 = shared->n_group;
  shared->dim_I = shared->n_group;
  shared->dim_I0 = shared->n_group;
  shared->dim_N = shared->n_group;
  shared->dim_R = shared->n_group;
  shared->dim_R0 = shared->n_group;
  shared->dim_S1 = shared->n_group;
  shared->dim_S10 = shared->n_group;
  shared->dim_S2 = shared->n_group;
  shared->dim_S20 = shared->n_group;
  shared->dim_U = shared->n_group;
  shared->dim_U0 = shared->n_group;
  shared->dim_alpha = shared->n_group;
  shared->dim_foi = shared->n_group;
  shared->dim_lambda_1 = shared->n_group;
  shared->dim_lambda_2 = shared->n_group;
  shared->dim_m_1 = shared->n_group;
  shared->dim_m_2 = shared->n_group;
  shared->dim_n_A = shared->n_group;
  shared->dim_n_AR = shared->n_group;
  shared->dim_n_AU = shared->n_group;
  shared->dim_n_Ax = shared->n_group;
  shared->dim_n_E = shared->n_group;
  shared->dim_n_EI = shared->n_group;
  shared->dim_n_ES = shared->n_group;
  shared->dim_n_Ex = shared->n_group;
  shared->dim_n_F = shared->n_group;
  shared->dim_n_FR = shared->n_group;
  shared->dim_n_Fx = shared->n_group;
  shared->dim_n_I = shared->n_group;
  shared->dim_n_IR = shared->n_group;
  shared->dim_n_Ix = shared->n_group;
  shared->dim_n_Nx = shared->n_group;
  shared->dim_n_R = shared->n_group;
  shared->dim_n_RU = shared->n_group;
  shared->dim_n_Rx = shared->n_group;
  shared->dim_n_S1 = shared->n_group;
  shared->dim_n_S1x = shared->n_group;
  shared->dim_n_S2 = shared->n_group;
  shared->dim_n_S2x = shared->n_group;
  shared->dim_n_SF = shared->n_group;
  shared->dim_n_SR = shared->n_group;
  shared->dim_n_SS = shared->n_group;
  shared->dim_n_U = shared->n_group;
  shared->dim_n_UA = shared->n_group;
  shared->dim_n_UE = shared->n_group;
  shared->dim_n_Ux = shared->n_group;
  shared->dim_n_xU = shared->n_group;
  shared->dim_omega = shared->n_group;
  shared->dim_r_A = shared->n_group;
  shared->dim_r_AR = shared->n_group;
  shared->dim_r_AU = shared->n_group;
  shared->dim_r_E = shared->n_group;
  shared->dim_r_EI = shared->n_group;
  shared->dim_r_ES = shared->n_group;
  shared->dim_r_F = shared->n_group;
  shared->dim_r_FR = shared->n_group;
  shared->dim_r_I = shared->n_group;
  shared->dim_r_IR = shared->n_group;
  shared->dim_r_R = shared->n_group;
  shared->dim_r_RU = shared->n_group;
  shared->dim_r_S1 = shared->n_group;
  shared->dim_r_S2 = shared->n_group;
  shared->dim_r_SF = shared->n_group;
  shared->dim_r_SR = shared->n_group;
  shared->dim_r_SS = shared->n_group;
  shared->dim_r_U = shared->n_group;
  shared->dim_r_UA = shared->n_group;
  shared->dim_r_UE = shared->n_group;
  shared->A0 = user_get_array_fixed<real_type, 1>(user, "A0", shared->A0, {shared->dim_A0}, NA_REAL, NA_REAL);
  shared->E0 = user_get_array_fixed<real_type, 1>(user, "E0", shared->E0, {shared->dim_E0}, NA_REAL, NA_REAL);
  shared->F0 = user_get_array_fixed<real_type, 1>(user, "F0", shared->F0, {shared->dim_F0}, NA_REAL, NA_REAL);
  shared->I0 = user_get_array_fixed<real_type, 1>(user, "I0", shared->I0, {shared->dim_I0}, NA_REAL, NA_REAL);
  shared->R0 = user_get_array_fixed<real_type, 1>(user, "R0", shared->R0, {shared->dim_R0}, NA_REAL, NA_REAL);
  shared->S10 = user_get_array_fixed<real_type, 1>(user, "S10", shared->S10, {shared->dim_S10}, NA_REAL, NA_REAL);
  shared->S20 = user_get_array_fixed<real_type, 1>(user, "S20", shared->S20, {shared->dim_S20}, NA_REAL, NA_REAL);
  shared->U0 = user_get_array_fixed<real_type, 1>(user, "U0", shared->U0, {shared->dim_U0}, NA_REAL, NA_REAL);
  internal.foi = std::vector<real_type>(shared->dim_foi);
  shared->initial_A = std::vector<real_type>(shared->dim_A);
  shared->initial_E = std::vector<real_type>(shared->dim_E);
  shared->initial_F = std::vector<real_type>(shared->dim_F);
  shared->initial_I = std::vector<real_type>(shared->dim_I);
  shared->initial_N = std::vector<real_type>(shared->dim_N);
  shared->initial_R = std::vector<real_type>(shared->dim_R);
  shared->initial_S1 = std::vector<real_type>(shared->dim_S1);
  shared->initial_S2 = std::vector<real_type>(shared->dim_S2);
  shared->initial_U = std::vector<real_type>(shared->dim_U);
  internal.n_A = std::vector<real_type>(shared->dim_n_A);
  internal.n_AR = std::vector<real_type>(shared->dim_n_AR);
  internal.n_AU = std::vector<real_type>(shared->dim_n_AU);
  internal.n_Ax = std::vector<real_type>(shared->dim_n_Ax);
  internal.n_E = std::vector<real_type>(shared->dim_n_E);
  internal.n_EI = std::vector<real_type>(shared->dim_n_EI);
  internal.n_ES = std::vector<real_type>(shared->dim_n_ES);
  internal.n_Ex = std::vector<real_type>(shared->dim_n_Ex);
  internal.n_F = std::vector<real_type>(shared->dim_n_F);
  internal.n_FR = std::vector<real_type>(shared->dim_n_FR);
  internal.n_Fx = std::vector<real_type>(shared->dim_n_Fx);
  internal.n_I = std::vector<real_type>(shared->dim_n_I);
  internal.n_IR = std::vector<real_type>(shared->dim_n_IR);
  internal.n_Ix = std::vector<real_type>(shared->dim_n_Ix);
  internal.n_Nx = std::vector<real_type>(shared->dim_n_Nx);
  internal.n_R = std::vector<real_type>(shared->dim_n_R);
  internal.n_RU = std::vector<real_type>(shared->dim_n_RU);
  internal.n_Rx = std::vector<real_type>(shared->dim_n_Rx);
  internal.n_S1 = std::vector<real_type>(shared->dim_n_S1);
  internal.n_S1x = std::vector<real_type>(shared->dim_n_S1x);
  internal.n_S2 = std::vector<real_type>(shared->dim_n_S2);
  internal.n_S2x = std::vector<real_type>(shared->dim_n_S2x);
  internal.n_SF = std::vector<real_type>(shared->dim_n_SF);
  internal.n_SR = std::vector<real_type>(shared->dim_n_SR);
  internal.n_SS = std::vector<real_type>(shared->dim_n_SS);
  internal.n_U = std::vector<real_type>(shared->dim_n_U);
  internal.n_UA = std::vector<real_type>(shared->dim_n_UA);
  internal.n_UE = std::vector<real_type>(shared->dim_n_UE);
  internal.n_Ux = std::vector<real_type>(shared->dim_n_Ux);
  internal.n_xU = std::vector<real_type>(shared->dim_n_xU);
  shared->r_A = std::vector<real_type>(shared->dim_r_A);
  shared->r_AR = std::vector<real_type>(shared->dim_r_AR);
  shared->r_AU = std::vector<real_type>(shared->dim_r_AU);
  shared->r_E = std::vector<real_type>(shared->dim_r_E);
  shared->r_EI = std::vector<real_type>(shared->dim_r_EI);
  shared->r_ES = std::vector<real_type>(shared->dim_r_ES);
  shared->r_F = std::vector<real_type>(shared->dim_r_F);
  shared->r_FR = std::vector<real_type>(shared->dim_r_FR);
  shared->r_I = std::vector<real_type>(shared->dim_r_I);
  shared->r_IR = std::vector<real_type>(shared->dim_r_IR);
  shared->r_R = std::vector<real_type>(shared->dim_r_R);
  shared->r_RU = std::vector<real_type>(shared->dim_r_RU);
  shared->r_S1 = std::vector<real_type>(shared->dim_r_S1);
  shared->r_S2 = std::vector<real_type>(shared->dim_r_S2);
  shared->r_SF = std::vector<real_type>(shared->dim_r_SF);
  shared->r_SR = std::vector<real_type>(shared->dim_r_SR);
  shared->r_SS = std::vector<real_type>(shared->dim_r_SS);
  internal.r_U = std::vector<real_type>(shared->dim_r_U);
  internal.r_UA = std::vector<real_type>(shared->dim_r_UA);
  internal.r_UE = std::vector<real_type>(shared->dim_r_UE);
  shared->alpha = user_get_array_fixed<real_type, 1>(user, "alpha", shared->alpha, {shared->dim_alpha}, NA_REAL, NA_REAL);
  shared->dim_lambda = shared->dim_lambda_1 * shared->dim_lambda_2;
  shared->dim_m = shared->dim_m_1 * shared->dim_m_2;
  shared->offset_variable_A = shared->dim_U + 8;
  shared->offset_variable_E = shared->dim_A + shared->dim_U + 8;
  shared->offset_variable_F = shared->dim_A + shared->dim_E + shared->dim_I + shared->dim_S1 + shared->dim_S2 + shared->dim_U + 8;
  shared->offset_variable_I = shared->dim_A + shared->dim_E + shared->dim_U + 8;
  shared->offset_variable_N = shared->dim_A + shared->dim_E + shared->dim_F + shared->dim_I + shared->dim_R + shared->dim_S1 + shared->dim_S2 + shared->dim_U + 8;
  shared->offset_variable_R = shared->dim_A + shared->dim_E + shared->dim_F + shared->dim_I + shared->dim_S1 + shared->dim_S2 + shared->dim_U + 8;
  shared->offset_variable_S1 = shared->dim_A + shared->dim_E + shared->dim_I + shared->dim_U + 8;
  shared->offset_variable_S2 = shared->dim_A + shared->dim_E + shared->dim_I + shared->dim_S1 + shared->dim_U + 8;
  shared->omega = user_get_array_fixed<real_type, 1>(user, "omega", shared->omega, {shared->dim_omega}, NA_REAL, NA_REAL);
  internal.lambda = std::vector<real_type>(shared->dim_lambda);
  for (int i = 1; i <= shared->dim_A; ++i) {
    shared->initial_A[i - 1] = shared->A0[i - 1];
  }
  for (int i = 1; i <= shared->dim_E; ++i) {
    shared->initial_E[i - 1] = shared->E0[i - 1];
  }
  for (int i = 1; i <= shared->dim_F; ++i) {
    shared->initial_F[i - 1] = shared->F0[i - 1];
  }
  for (int i = 1; i <= shared->dim_I; ++i) {
    shared->initial_I[i - 1] = shared->I0[i - 1];
  }
  for (int i = 1; i <= shared->dim_N; ++i) {
    shared->initial_N[i - 1] = shared->U0[i - 1] + shared->A0[i - 1] + shared->E0[i - 1] + shared->I0[i - 1] + shared->S10[i - 1] + shared->S20[i - 1] + shared->F0[i - 1] + shared->R0[i - 1];
  }
  for (int i = 1; i <= shared->dim_R; ++i) {
    shared->initial_R[i - 1] = shared->R0[i - 1];
  }
  for (int i = 1; i <= shared->dim_S1; ++i) {
    shared->initial_S1[i - 1] = shared->S10[i - 1];
  }
  for (int i = 1; i <= shared->dim_S2; ++i) {
    shared->initial_S2[i - 1] = shared->S20[i - 1];
  }
  for (int i = 1; i <= shared->dim_U; ++i) {
    shared->initial_U[i - 1] = shared->U0[i - 1];
  }
  shared->m = user_get_array_fixed<real_type, 2>(user, "m", shared->m, {shared->dim_m_1, shared->dim_m_2}, NA_REAL, NA_REAL);
  for (int i = 1; i <= shared->dim_r_AR; ++i) {
    shared->r_AR[i - 1] = shared->p_R / (real_type) shared->delta_A;
  }
  for (int i = 1; i <= shared->dim_r_AU; ++i) {
    shared->r_AU[i - 1] = (1 - shared->p_R) / (real_type) shared->delta_A;
  }
  for (int i = 1; i <= shared->dim_r_EI; ++i) {
    shared->r_EI[i - 1] = shared->p_I / (real_type) shared->delta_E;
  }
  for (int i = 1; i <= shared->dim_r_ES; ++i) {
    shared->r_ES[i - 1] = (1 - shared->p_I) / (real_type) shared->delta_E;
  }
  for (int i = 1; i <= shared->dim_r_FR; ++i) {
    shared->r_FR[i - 1] = 1 / (real_type) shared->delta_F;
  }
  for (int i = 1; i <= shared->dim_r_IR; ++i) {
    shared->r_IR[i - 1] = 1 / (real_type) shared->delta_I;
  }
  for (int i = 1; i <= shared->dim_r_RU; ++i) {
    shared->r_RU[i - 1] = 1 / (real_type) shared->delta_R;
  }
  for (int i = 1; i <= shared->dim_r_SF; ++i) {
    shared->r_SF[i - 1] = shared->p_F / (real_type) shared->delta_S;
  }
  for (int i = 1; i <= shared->dim_r_SR; ++i) {
    shared->r_SR[i - 1] = 1 / (real_type) shared->delta_S;
  }
  for (int i = 1; i <= shared->dim_r_SS; ++i) {
    shared->r_SS[i - 1] = (1 - shared->p_F) / (real_type) shared->delta_S;
  }
  for (int i = 1; i <= shared->dim_r_A; ++i) {
    shared->r_A[i - 1] = shared->r_AU[i - 1] + shared->r_AR[i - 1] + shared->omega[i - 1];
  }
  for (int i = 1; i <= shared->dim_r_E; ++i) {
    shared->r_E[i - 1] = shared->r_EI[i - 1] + shared->r_ES[i - 1] + shared->omega[i - 1];
  }
  for (int i = 1; i <= shared->dim_r_F; ++i) {
    shared->r_F[i - 1] = shared->r_FR[i - 1] + shared->omega[i - 1];
  }
  for (int i = 1; i <= shared->dim_r_I; ++i) {
    shared->r_I[i - 1] = shared->r_IR[i - 1] + shared->omega[i - 1];
  }
  for (int i = 1; i <= shared->dim_r_R; ++i) {
    shared->r_R[i - 1] = shared->r_RU[i - 1] + shared->omega[i - 1];
  }
  for (int i = 1; i <= shared->dim_r_S1; ++i) {
    shared->r_S1[i - 1] = shared->r_SF[i - 1] + shared->r_SS[i - 1] + shared->omega[i - 1];
  }
  for (int i = 1; i <= shared->dim_r_S2; ++i) {
    shared->r_S2[i - 1] = shared->r_SR[i - 1] + shared->omega[i - 1];
  }
  return dust::pars_type<model>(shared, internal);
}
template <>
cpp11::sexp dust_info<model>(const dust::pars_type<model>& pars) {
  const model::internal_type internal = pars.internal;
  const std::shared_ptr<const model::shared_type> shared = pars.shared;
  cpp11::writable::strings nms({"time", "infections_inc", "pharyngitis_inc", "scarlet_fever_inc", "igas_inc", "entrants_inc", "leavers_inc", "beta_t", "U", "A", "E", "I", "S1", "S2", "F", "R", "N"});
  cpp11::writable::list dim(17);
  dim[0] = cpp11::writable::integers({1});
  dim[1] = cpp11::writable::integers({1});
  dim[2] = cpp11::writable::integers({1});
  dim[3] = cpp11::writable::integers({1});
  dim[4] = cpp11::writable::integers({1});
  dim[5] = cpp11::writable::integers({1});
  dim[6] = cpp11::writable::integers({1});
  dim[7] = cpp11::writable::integers({1});
  dim[8] = cpp11::writable::integers({shared->dim_U});
  dim[9] = cpp11::writable::integers({shared->dim_A});
  dim[10] = cpp11::writable::integers({shared->dim_E});
  dim[11] = cpp11::writable::integers({shared->dim_I});
  dim[12] = cpp11::writable::integers({shared->dim_S1});
  dim[13] = cpp11::writable::integers({shared->dim_S2});
  dim[14] = cpp11::writable::integers({shared->dim_F});
  dim[15] = cpp11::writable::integers({shared->dim_R});
  dim[16] = cpp11::writable::integers({shared->dim_N});
  dim.names() = nms;
  cpp11::writable::list index(17);
  index[0] = cpp11::writable::integers({1});
  index[1] = cpp11::writable::integers({2});
  index[2] = cpp11::writable::integers({3});
  index[3] = cpp11::writable::integers({4});
  index[4] = cpp11::writable::integers({5});
  index[5] = cpp11::writable::integers({6});
  index[6] = cpp11::writable::integers({7});
  index[7] = cpp11::writable::integers({8});
  index[8] = integer_sequence(9, shared->dim_U);
  index[9] = integer_sequence(shared->offset_variable_A + 1, shared->dim_A);
  index[10] = integer_sequence(shared->offset_variable_E + 1, shared->dim_E);
  index[11] = integer_sequence(shared->offset_variable_I + 1, shared->dim_I);
  index[12] = integer_sequence(shared->offset_variable_S1 + 1, shared->dim_S1);
  index[13] = integer_sequence(shared->offset_variable_S2 + 1, shared->dim_S2);
  index[14] = integer_sequence(shared->offset_variable_F + 1, shared->dim_F);
  index[15] = integer_sequence(shared->offset_variable_R + 1, shared->dim_R);
  index[16] = integer_sequence(shared->offset_variable_N + 1, shared->dim_N);
  index.names() = nms;
  size_t len = shared->offset_variable_N + shared->dim_N;
  using namespace cpp11::literals;
  return cpp11::writable::list({
           "dim"_nm = dim,
           "len"_nm = len,
           "index"_nm = index});
}
}

cpp11::sexp dust_model_capabilities() {
  return dust::r::dust_capabilities<model>();
}

cpp11::sexp dust_model_gpu_info() {
  return dust::gpu::r::gpu_info();
}
using model_cpu = dust::dust_cpu<model>;

SEXP dust_cpu_model_alloc(cpp11::list r_pars, bool pars_multi, size_t step,
                             cpp11::sexp r_n_particles, size_t n_threads,
                             cpp11::sexp r_seed, bool deterministic,
                             cpp11::sexp gpu_config) {
  return dust::r::dust_cpu_alloc<model>(r_pars, pars_multi, step, r_n_particles,
                                        n_threads, r_seed, deterministic,
                                        gpu_config);
}

SEXP dust_cpu_model_run(SEXP ptr, size_t step_end) {
  return dust::r::dust_run<model_cpu>(ptr, step_end);
}

SEXP dust_cpu_model_simulate(SEXP ptr, cpp11::sexp step_end) {
  return dust::r::dust_simulate<model_cpu>(ptr, step_end);
}

SEXP dust_cpu_model_set_index(SEXP ptr, cpp11::sexp r_index) {
  dust::r::dust_set_index<model_cpu>(ptr, r_index);
  return R_NilValue;
}

SEXP dust_cpu_model_update_state(SEXP ptr, SEXP r_pars, SEXP r_state,
                                SEXP r_step, SEXP r_set_initial_state) {
  return dust::r::dust_update_state<model_cpu>(ptr, r_pars, r_state, r_step,
                                               r_set_initial_state);
}

SEXP dust_cpu_model_state(SEXP ptr, SEXP r_index) {
  return dust::r::dust_state<model_cpu>(ptr, r_index);
}

size_t dust_cpu_model_step(SEXP ptr) {
  return dust::r::dust_step<model_cpu>(ptr);
}

void dust_cpu_model_reorder(SEXP ptr, cpp11::sexp r_index) {
  return dust::r::dust_reorder<model_cpu>(ptr, r_index);
}

SEXP dust_cpu_model_resample(SEXP ptr, cpp11::doubles r_weights) {
  return dust::r::dust_resample<model_cpu>(ptr, r_weights);
}

SEXP dust_cpu_model_rng_state(SEXP ptr, bool first_only, bool last_only) {
  return dust::r::dust_rng_state<model_cpu>(ptr, first_only, last_only);
}

SEXP dust_cpu_model_set_rng_state(SEXP ptr, cpp11::raws rng_state) {
  dust::r::dust_set_rng_state<model_cpu>(ptr, rng_state);
  return R_NilValue;
}

SEXP dust_cpu_model_set_data(SEXP ptr, cpp11::list data) {
  dust::r::dust_set_data<model_cpu>(ptr, data);
  return R_NilValue;
}

SEXP dust_cpu_model_compare_data(SEXP ptr) {
  return dust::r::dust_compare_data<model_cpu>(ptr);
}

SEXP dust_cpu_model_filter(SEXP ptr, bool save_trajectories,
                          cpp11::sexp step_snapshot) {
  return dust::r::dust_filter<model_cpu>(ptr, save_trajectories, step_snapshot);
}

void dust_cpu_model_set_n_threads(SEXP ptr, int n_threads) {
  return dust::r::dust_set_n_threads<model_cpu>(ptr, n_threads);
}

int dust_cpu_model_n_state(SEXP ptr) {
  return dust::r::dust_n_state<model_cpu>(ptr);
}
